TASK5.3
Part1

В Линуксе процесс может иметь пять состояний: рождение, выполненин, ожидание, готовность и смерть. Также процессы иногда могут быть в состоянии "зомби".

Команда Pstree отображает древовидную структуру всех запущенных процессов пользователя.

Proc - это виртуальная файловая система и она не занимает места на диске. Это удобный способ получить информацию о системе. Большинство программ получают информацию из файлов в /proc. 

Посмотреть информацию о процессоре можно с помощью команды cat /proc/cpuinfo

Чтобы получить полную информацию о процессе можно использовать команду ps -ef, лучше всего в комбинации с командой more: ps -eF | more.

Посмотреть запущенные процессы можно с помощью команды htop. Она позволяет выполнить поиск среди процессов, сортировку, понизить приоритет, убить процесс.

Вывод процессов в виде дерева: htop -t

Чтобы увидеть только kernel processes можно использововать команду: pstree 2. 

pstree без параметров показывает только дерево пользовательских процессов.

Чтобы посмотреть статус процесса можно использовать команду: ps aux. Статус будет указан в колонке Stat. R - активный запущенный процесс, S - спящий процесс, T – приостановленный процесс, Z - зомби-процесс, D – находится в состоянии непрерывного ожидания.

Отобразить процессы конкретного пользователя можно командой: ps -fU username

Отображение групповых процессов: ps -fG adm

Вывести дерево процессов: ps -e --forest

Команда top позволяет выводить информацию о системе, список процессов с обновлением информации о потребляемых ими ресурсах.

Чтобы выбрать процессы определенного пользователя нужно нажать U, а затем ввести имя пользователя.

После запуска top можно использовать интерактивные команды: L - поиск по слову, i - переключение режима отображения процессов, которые сейчас не используют ресурсы процессора, V - отображение процессов в виде дерева, H - выводить потоки процессов, и т.д.

Отсортируйте содержимое окна процессов по количеству занятого процессором времени: интерактивная команда O, а затем ввести команду Time.

Приоритет процесса означает, насколько больше процессорного времени будет отдано этому процессу по сравнению с другими.  Значение приоритета может колебаться от 19 (минимальный приоритет) до -20 (максимальный приоритет).

Для управления приоритетом можно использовать параметр Nice в команде htop (F7 для увеличения приоритета или F8 - для уменьшения).

Приоритет запускаемого процесса можно указать командой nice в командной строке: nice -n 10 имя процесса. 

Изменить приоритет существующего процесса можно командой renice: renice -n 10 имя процесса.

Командой top можно изменить приоритет запущенных процессов. Для этого нужно нажать r,  затем ввести PID процесса, а после этого в поле Renice PID № to value изменить значение приоритета. 

Команда kill посылает сигнал для закрытия процесса. Наиболее чаще используемые сигналы - SIGTERM (15) и SIGKILL (9). SIGTERM - сигнал запрашивает остановку работы процесса. Он может быть проигнорирован. SIGKILL - сигнал заставляет процесс прекратить работу немедленно.

Пример использования команды SIGKILL

kill SIGKILL PID или kill -9 PID

Еще одним вариантом является команды pkill имя процесса

Команда killall завершает все процессы с заданным именем.

Комнады jobs, fg, bg нужны для управления фоновыми процессами.

Каждая команда со знаком амперсанда (&) на конце превращает работу команду в фоновую. Команда jobs отображает фоновые задачи в настоящий момент, fg - вывести фоновую задачу в оболочку, bg - отправить задачу в фон.

Nohup позволяет запустить процесс даже после выхода из системы. Nohup перехватывает сигнал о завершении сеанса и позволяет команде выполняться в фоновом режиме. Синтаксис команды такой: nohup command &

Команда sleep приостановливает выполнение на время выполнения любого скрипта. Ее можно отправить в фон и вывести из него.

Пример
sleep 100
Ctrl+z
bg - в фон
fg - из фона

Команда Yes бесконечно выводит аргументы командной строки, пока не будет убита. Если в командной строке не задано аргументов, то бесконечно выводит строку y. Ее можно использовать в скриптах. 



Part2

Установил на ПК с Windows OpenSSH. Для этого мне пришлось добавить путь в системную переменную Path.

Сгенерировал ключ типа RSA командой ssh-keygen.

После этого скопировал ключ в Linux-машину командой scp.

Загрузил ключ в файл authorized-keys на Linux.

Проверил работу ssh-соединения через cmd и Powershell.

Для повышения безопасности в ssh можно использовать несколько методов:

- в sshd_config изменить параметр PermitRootLogin на no, чтобы запретить вход в систему с правами root

- в параметрах AllowUsers, AllowGroups указать только тех пользователей, которые имеют право работать через ssh.
AllowUsers username
AllowGroups groupname

- либо можно запретить доступ определенным пользователям, указав их в параметрах DenyUsers, DenyGroups
DenyUsers username
DenyGroups groupname

- можно заменить ssh-порт, который по умолчанию 22, на другой в параметре Port.

- можно указать конкретные адреса интерфейсов для входа на сервер в параметре ListenAddress.

- установить тайм-аут по бездействию. Параметр ClientAliveInterval

Сгенерировал ключ типа DSA командой ssh-keygen -t dsa

Соединился с удаленной машиной с помощью ключа dsa

Сгенерировал ключ типа ECDSA командой ssh-keygen -t ecdsa

Соединился с удаленной машиной с помощью ключа ecdsa


Изначально Wireshark не отображал мой сетевой интерфейс. Чтобы решить эту проблему я использовал команду sudo dpkg-reconfigure wireshark-common и добавил моего пользователя в Wireshark sudo adduser stas wireshark.
